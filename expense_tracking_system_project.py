# -*- coding: utf-8 -*-
"""Expense_Tracking_System_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WqMTJ6Z3Uk8OFLD4pjOVWkbuIPtM85Z3

**Packages to load in **
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

"""**Data Loading**"""

df_automobile = pd.read_csv("CAR.csv")
df_automobile

"""**Admin Access**

1.Adding
  2.updating
  3.deleteing
"""

import pandas as pd


df_automobile = pd.read_csv("CAR.csv")

# Function to add data to the DataFrame
def add_data(dataframe):
    new_data = {}
    for col in dataframe.columns:
        new_data[col] = input(f"Enter {col}: ")
    dataframe = dataframe.append(new_data, ignore_index=True)
    return dataframe

# Function to update data in the DataFrame
def update_data(dataframe):
    index_to_update = int(input("Enter the index of the entry to update: "))
    column_to_update = input("Enter the column to update: ")
    new_value = input("Enter the new value: ")
    dataframe.at[index_to_update, column_to_update] = new_value
    return dataframe

# Function to delete data from the DataFrame
def delete_data(dataframe):
    index_to_delete = int(input("Enter the index of the entry to delete: "))
    dataframe = dataframe.drop(index_to_delete)
    dataframe = dataframe.reset_index(drop=True)
    return dataframe


while True:
    choice = input("Enter 'A' to add data, 'U' to update data, 'D' to delete data, or 'Q' to quit: ").upper()

    if choice == 'A':
        df_automobile = add_data(df_automobile)
    elif choice == 'U':
        df_automobile = update_data(df_automobile)
    elif choice == 'D':
        df_automobile = delete_data(df_automobile)
    elif choice == 'Q':
        break
    else:
        print("Invalid choice. Please try again.")


print(df_automobile)

"""**Data Cleaning**

*Data contains "?" replace it with NAN *
"""

df_data = df_automobile.replace('?',np.NAN)
df_data.isnull().sum()

"""**Missing Data**

fill missing data of normalised-losses, Price, and many with the respective column mean
Fill missing data category Number of doors with the mode of the column i.e. Four
"""

# Handling NaN values in 'Normalized-Losses'
df_temp = df_automobile[df_automobile['Normalized-Losses']!='?']
normalised_mean = df_temp['Normalized-Losses'].astype(float).mean()
df_automobile['Normalized-Losses'] = df_automobile['Normalized-Losses'].replace('?',normalised_mean).astype(float)

# Handling NaN values in 'Price'
df_temp = df_automobile[df_automobile['Price']!='?']
normalised_mean = df_temp['Price'].astype(float).mean()
df_automobile['Price'] = df_automobile['Price'].replace('?',normalised_mean).astype(float)



df_temp = df_automobile[df_automobile['horsepower']!='?']
normalised_mean = df_temp['horsepower'].astype(int).mean()
df_automobile['horsepower'] = df_automobile['horsepower'].replace('?',normalised_mean).astype(int)

df_temp = df_automobile[df_automobile['peak-rpm']!='?']
normalised_mean = df_temp['peak-rpm'].astype(int).mean()
df_automobile['peak-rpm'] = df_automobile['peak-rpm'].replace('?',normalised_mean).astype(int)

df_temp = df_automobile[df_automobile['bore']!='?']
normalised_mean = df_temp['bore'].astype(float).mean()
df_automobile['bore'] = df_automobile['bore'].replace('?',normalised_mean).astype(float)

df_temp = df_automobile[df_automobile['stroke']!='?']
normalised_mean = df_temp['stroke'].astype(float).mean()
df_automobile['stroke'] = df_automobile['stroke'].replace('?',normalised_mean).astype(float)

# Handling NaN values in 'Num-Of-Doors'
df_automobile['Num-Of-Doors'] = df_automobile['Num-Of-Doors'].replace('?','four')

# Other columns can be handled similarly

# Example for 'Mileage'
df_temp = df_automobile[df_automobile['Mileage']!='?']
normalised_mean = df_temp['Mileage'].astype(float).mean()
df_automobile['Mileage'] = df_automobile['Mileage'].replace('?',normalised_mean).astype(float)

# Example for 'Year'
df_temp = df_automobile[df_automobile['Year']!='?']
normalised_mean = df_temp['Year'].astype(float).mean()
df_automobile['Year'] = df_automobile['Year'].replace('?',normalised_mean).astype(float)

# Example for 'Fuel-Type'
df_automobile['Fuel-Type'] = df_automobile['Fuel-Type'].fillna('Unknow')

# Example for 'Model'
df_automobile['Model'] = df_automobile['Model'].fillna('Unknown')

# Example for 'Make'
df_automobile['Make'] = df_automobile['Make'].fillna('Unknown')

# Example for 'Body-Style'
df_automobile['Body-Style'] = df_automobile['Body-Style'].fillna('Unknown')

# Example for 'Drive-Wheels'
df_automobile['Drive-Wheels'] = df_automobile['Drive-Wheels'].fillna('Unknown')

# Example for 'Engine-Location'
df_automobile['Engine-Location'] = df_automobile['Engine-Location'].fillna('Unknown')

# Example for 'Condition'
df_automobile['Condition'] = df_automobile['Condition'].fillna('Unknown')

# Example for 'Payment method '
df_automobile['Payment method'] = df_automobile['Payment method'].fillna('Unknown')

# Example for 'Payment method '
df_automobile['Payment method'] = df_automobile['Payment method'].fillna('Unknown')

# Example for 'Maintenance-Costs '
df_automobile['Maintenance-Costs'] = df_automobile['Maintenance-Costs'].fillna('Unknown')

# Example for 'Date '
df_automobile['Date'] = df_automobile['Date'].fillna('Unknown')





# You can adapt this pattern for the other columns as well .



# Save the updated DataFrame to a new CSV file
df_automobile.to_csv('car1.csv', index=False)

df_automobile.head()

"""**Summary statistics of variable**"""

df_automobile.describe()

"""**Transpose**"""

df_automobile.describe().T

"""**User Module**
 1. View Expenses of Cars by Make
 2. Track Fuel Costs for a Car
 3. Track Maintenance Costs for a Car
 4. Track Insurance Costs for a Car
 5. Track Depreciation for a Car
 6. Choose a Car to View Details
"""

df_automobile = pd.read_csv("car1.csv")
df_automobile['Date'] = pd.to_datetime(df_automobile['Date'])
# Function to add data to the DataFrame
def add_data(dataframe):
    new_data = {}
    for col in dataframe.columns:
        new_data[col] = input(f"Enter {col}: ")
    dataframe = dataframe.append(new_data, ignore_index=True)
    return dataframe

# Function to update data in the DataFrame
def update_data(dataframe):
    index_to_update = int(input("Enter the index of the entry to update: "))
    if 0 <= index_to_update < len(dataframe):
        column_to_update = input("Enter the column to update: ")
        if column_to_update in dataframe.columns:
            new_value = input("Enter the new value: ")
            dataframe.at[index_to_update, column_to_update] = new_value
        else:
            print("Invalid column name.")
    else:
        print("Invalid index.")
    return dataframe

# Function to delete data from the DataFrame
def delete_data(dataframe):
    index_to_delete = int(input("Enter the index of the entry to delete: "))
    if 0 <= index_to_delete < len(dataframe):
        dataframe = dataframe.drop(index_to_delete)
        dataframe = dataframe.reset_index(drop=True)
    else:
        print("Invalid index.")
    return dataframe
# Function to view expenses of cars
def view_car_expenses(dataframe, choice):
    if choice == '1':
        make = input("Enter the make of the car: ")
        if make in dataframe['Make'].unique():
            cars_by_make = dataframe[dataframe['Make'] == make]
            cars_by_make['Price'] = pd.to_numeric(cars_by_make['Price'], errors='coerce')
            cars_by_make = cars_by_make.dropna(subset=['Price'])
            total_amount = sum(cars_by_make['Price'])
            print(cars_by_make)
            print(f"Total amount for {make}: {total_amount}")
            years = cars_by_make['Year']
            plt.pie(cars_by_make['Price'], labels=years, autopct='%1.1f%%')
            plt.title(f"Expenses for {make} by Year")
            plt.show()
        else:
            print("No cars found with the specified make.")


# Function to track fuel costs
def track_fuel_costs(dataframe, car_index):
    car_data = dataframe.iloc[car_index]
    car_mileage = pd.to_numeric(car_data["Mileage"], errors='coerce')
    car_fuel_type = pd.to_numeric(car_data["Fuel-Type"], errors='coerce')

    # Calculate fuel costs based on mileage and fuel type
    fuel_costs = car_mileage * car_fuel_type

    # Visualize fuel costs
    plt.bar(['Mileage', 'Fuel Type'], [car_mileage, car_fuel_type])
    plt.title(f'Fuel Costs for {car_data["Make"]} {car_data["Model"]}')
    plt.xlabel('Category')
    plt.ylabel('Value')
    plt.show()

# Function to track maintenance costs
def track_maintenance_costs(dataframe, car_index):
    car_data = dataframe.iloc[car_index]
    maintenance_types = ['Excellent', 'Good', 'Fair', 'Poor']
    maintenance_costs = [0, 0, 0, 0]

    for index, row in dataframe.iterrows():
        if row['Condition'] == 'Excellent':
            maintenance_costs[0] += row['Maintenance-Costs']
        elif row['Condition'] == 'Good':
            maintenance_costs[1] += row['Maintenance-Costs']
        elif row['Condition'] == 'Fair':
            maintenance_costs[2] += row['Maintenance-Costs']
        elif row['Condition'] == 'Poor':
            maintenance_costs[3] += row['Maintenance-Costs']

    # Visualize maintenance costs
    plt.bar(maintenance_types, maintenance_costs)
    plt.title(f'Maintenance Costs for {car_data["Make"]} {car_data["Model"]}')
    plt.xlabel('Condition')
    plt.ylabel('Costs')
    plt.show()

# Function to track insurance costs
def track_insurance_costs(dataframe, car_index):
    car_data = dataframe.iloc[car_index]

    # Logic to calculate insurance costs
    insurance_costs = 500 + (2023 - car_data['Year']) * 100  #Example formula for insurance costs

    # Visualize insurance costs
    factors = ['Basic Coverage', 'Collision Coverage', 'Comprehensive Coverage']
    costs = [insurance_costs * 0.6, insurance_costs * 0.3, insurance_costs * 0.1]  # Example distribution of insurance costs
    plt.bar(factors, costs)
    plt.title(f'Insurance Costs for {car_data["Make"]} {car_data["Model"]}')
    plt.xlabel('Insurance Types')
    plt.ylabel('Costs')
    plt.show()


# Function to track depreciation
def track_depreciation(dataframe, car_index):
    car_data = dataframe.iloc[car_index]

    # Logic to calculate depreciation
    start_year = int(car_data['Year'])  # Convert to integer type
    years = [year for year in range(start_year, 2024)]  # Example list of years for the calculation
    depreciation = [5000 * (1 - (year - start_year) * 0.1) for year in years]  # Example formula for depreciation

    # Visualize depreciation
    plt.plot(years, depreciation, marker='o')
    plt.title(f'Depreciation for {car_data["Make"]} {car_data["Model"]}')
    plt.xlabel('Years')
    plt.ylabel('Value ($)')
    plt.show()



# Example usage
while True:
    print("1. View Expenses of Cars by Make")
    print("2. Track Fuel Costs for a Car")
    print("3. Track Maintenance Costs for a Car")
    print("4. Track Insurance Costs for a Car")
    print("5. Track Depreciation for a Car")
    print("6. Choose a Car to View Details")
    print("7. Quit")
    choice = input("Enter your choice: ")

    if choice == '1':
        view_car_expenses(df_automobile, choice)
    elif choice == '2':
        car_index = int(input("Enter the index of the car: "))
        track_fuel_costs(df_automobile, car_index)
    elif choice == '3':
        car_index = int(input("Enter the index of the car: "))
        if 0 <= car_index < len(df_automobile):
            track_maintenance_costs(df_automobile, car_index)
        else:
            print("Invalid index.")
    elif choice == '4':
        car_index = int(input("Enter the index of the car: "))
        track_insurance_costs(df_automobile, car_index)
    elif choice == '5':
        car_index = int(input("Enter the index of the car: "))
        track_depreciation(df_automobile, car_index)
    elif choice == '6':
        index = int(input("Enter the index of the car: "))
        if 0 <= index < len(df_automobile):
            print(df_automobile.iloc[index])
        else:
            print("Invalid index.")
    elif choice == '7':
        break
    else:
        print("Invalid choice. Please try again.")

"""**Total Expenses by Payment Method**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load your dataset
df = pd.read_csv('car1.csv')

# Handling missing or invalid values
df = df.replace('?', pd.NA)  # Replace '?' with NaN for further processing
df = df.apply(pd.to_numeric, errors='ignore')  # Convert columns to numeric, ignore errors

# Convert the 'Date' column to a datetime type
df['Date'] = pd.to_datetime(df['Date'])

# Calculate expenses based on Price and Maintenance-Costs
df['Expense'] = df['Price'] + df['Maintenance-Costs']  # Adjust the calculation based on your specific expense calculation

# Convert the 'Expense' column to a numeric data type
df['Expense'] = pd.to_numeric(df['Expense'])

# Ensure that 'Payment method' is a categorical variable
df['Payment method'] = df['Payment method'].astype('category')

# Create a dashboard to show the expenses of different payment methods
# First, visualize the expenses based on payment method
plt.figure(figsize=(12, 6))
sns.barplot(x='Payment method', y='Expense', data=df, estimator=sum, ci=None)
plt.title('Total Expenses by Payment Method')
plt.xlabel('Payment Method')
plt.ylabel('Total Expenses')
plt.show()

# Next, create a time-based analysis of expenses
# For example, expenses by year
plt.figure(figsize=(12, 6))
sns.lineplot(x='Date', y='Expense', data=df, estimator=sum, ci=None)
plt.title('Expenses by Year')
plt.xlabel('Year')
plt.ylabel('Total Expenses')
plt.show()

# You can further customize and create more visualizations based on your requirements and dataset.

# Finally, calculate the total expenses by payment method
total_expenses = df.groupby('Payment method')['Expense'].sum()
print("Total Expenses by Payment Method:")
print(total_expenses)

"""**Machine learning & Visualization**"""

df_automobile = pd.read_csv("car1.csv")
df_automobile

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
import numpy as np

# Define features and target variable
features = ['engine-size', 'horsepower', 'curb-weight', 'city-mpg', 'engine-type']
target = 'Price'

# Split the data
X = df_automobile[features]
y = df_automobile[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Define a preprocessor for one-hot encoding
categorical_features = ['engine-type']
categorical_transformer = Pipeline(steps=[
    ('onehot', OneHotEncoder(sparse=False, handle_unknown='ignore'))
])

preprocessor = ColumnTransformer(
    transformers=[
        ('cat', categorical_transformer, categorical_features)
    ])

# Combine the preprocessor with the model
model = Pipeline(steps=[('preprocessor', preprocessor),
                       ('regressor', LinearRegression())])

# Train the model
model.fit(X_train, y_train)

# Make predictions and evaluate the model
y_pred = model.predict(X_test)
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print(f"Mean Absolute Error: {mae}")
print(f"Mean Squared Error: {mse}")
print(f"Root Mean Squared Error: {rmse}")
print(f"R-squared (R2): {r2}")

"""**prediction Price by car-wise**"""

# Assuming the previous code has been implemented

# Use the trained model to make predictions on the test data
y_pred = model.predict(X_test)

# Visualize the predictions
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred, c='blue', label='Scatter Plot')
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], 'k--', lw=2, c='red', label='Regression Line')
plt.xlabel('Actual Price')
plt.ylabel('Predicted Price')
plt.title('Actual Price vs. Predicted Price')
plt.legend()
plt.show()

# Evaluation Metrics
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print(f"Mean Absolute Error: {mae}")
print(f"Mean Squared Error: {mse}")
print(f"Root Mean Squared Error: {rmse}")
print(f"R-squared (R2): {r2}")

"""**prediction Price by car-wise**"""

# Assuming the previous code has been implemented

# Make predictions on the entire dataset
all_predictions = model.predict(X)

# Add the predicted prices as a new column in the DataFrame
df_automobile['predicted_price'] = all_predictions

# Display the car model-wise actual and predicted prices
car_model_prices = df_automobile[['Make', 'Price', 'predicted_price']].groupby('Make').mean()
car_model_prices.reset_index(inplace=True)

# Plot the car model-wise actual and predicted prices
plt.figure(figsize=(12, 6))
sns.barplot(x='Make', y='Price', data=car_model_prices, color='blue', label='Actual Price')
sns.barplot(x='Make', y='predicted_price', data=car_model_prices, color='red', label='Predicted Price')
plt.xticks(rotation=90)
plt.xlabel('Car Model')
plt.ylabel('Price')
plt.title('Car Model-wise Actual and Predicted Prices')
plt.legend()
plt.show()

"""**The expenses of the old price and the new predicted price**"""

import plotly.express as px

# Assuming df_automobile is the DataFrame containing the data

# Group data by 'Make' (car model) and calculate the mean of 'Price' and 'predicted_price'
car_prices = df_automobile.groupby('Make').agg({'Price': 'mean', 'predicted_price': 'mean'}).reset_index()

# Create an interactive bar plot using Plotly Express
fig = px.bar(car_prices, x='Make', y=['Price', 'predicted_price'], barmode='group',
             title='Expense Comparison of Old Price and New Predicted Price by Car Make')

# Add labels
fig.update_layout(xaxis_title='Car Make', yaxis_title='Price', legend_title='Price Type')

fig.show()

"""**Shows the total expenses of the old price of cars and the total of the new predicted price**"""

import matplotlib.pyplot as plt

# Assuming df_automobile is the DataFrame containing the data

# Calculate the total expenses of the old price of cars
total_old_price = df_automobile['Price'].sum()

# Calculate the total of the new predicted price
total_new_price = df_automobile['predicted_price'].sum()

# Data for the pie chart
labels = ['Total Old Price', 'Total New Predicted Price']
sizes = [total_old_price, total_new_price]
colors = ['#ff9999', '#66b3ff']

# Plotting the pie chart
plt.figure(figsize=(8, 6))
plt.pie(sizes, labels=labels, colors=colors, autopct=lambda p: '${:.0f}'.format(p * sum(sizes) / 100), startangle=90)
plt.title('Total Expenses of Old Price vs. Total of New Predicted Price')
plt.show()

import matplotlib.pyplot as plt

# Assuming df_automobile is the DataFrame containing the data

# Group the data by year and calculate the total expenses for each year
yearly_expenses = df_automobile.groupby('Year')['Price'].sum().reset_index()

# Assuming the current year is 2023, you can change it according to your requirement
current_year = 2023

# Filter the data for the current and future years
future_years = range(current_year + 1, current_year + 6)  # Predict for the next 5 years
future_expenses = []
for year in future_years:
    future_expense = df_automobile[df_automobile['Year'] == year]['predicted_price'].sum()
    future_expenses.append(future_expense)

# Visualize the yearly expenses and future spend prediction
plt.figure(figsize=(10, 6))
plt.plot(yearly_expenses['Year'], yearly_expenses['Price'], marker='o', linestyle='-', color='b', label='Yearly Expenses')
plt.plot(future_years, future_expenses, marker='o', linestyle='--', color='r', label='Future Spend Prediction')
plt.xlabel('Year')
plt.ylabel('Total Expenses')
plt.title('Yearly Expenses and Future Spend Prediction')
plt.legend()
plt.show()

# Calculating the amount needed in the account for future orders
future_order_amount = sum(future_expenses) - sum(yearly_expenses[yearly_expenses['Year'] == current_year]['Price'])
print(f"Amount needed in the account for future orders: {future_order_amount}")

import pandas as pd
import plotly.express as px

# Assuming df_automobile is the DataFrame containing the data

# Calculate expenses as 3/4 of the price
df_automobile['expenses'] = df_automobile['Price'] * 3/4  # Adjust the factor according to your expense calculation

# Calculate insurance as 1/20 of the price
df_automobile['insurance'] = df_automobile['Price'] * 1/20  # Adjust the factor according to your insurance calculation

# Group data by 'Make' (car model), 'Year', and 'Condition' columns and calculate the mean price, expenses, and insurance
expensive_data = df_automobile.groupby(['Make', 'Year', 'Condition'])[['Price', 'expenses', 'insurance']].mean().reset_index()

# Create an interactive line plot using Plotly Express
fig = px.line(expensive_data, x='Year', y='insurance', color='Make', title="Average Insurance Trend by Car Model and Year")

# Add a dropdown menu for car model selection
fig.update_layout(updatemenus=[dict(type="dropdown", showactive=True, buttons=[
    dict(label=car_model, method="update", args=[{"y": [expensive_data[expensive_data['Make'] == car_model]['insurance']]}])
    for car_model in expensive_data['Make'].unique()
])])

# Show the interactive line plot
fig.show()

import plotly.express as px

# Assuming df_automobile is your DataFrame
fig = px.histogram(df_automobile, x='Price', nbins=30, title='Price Distribution')
fig.show()

"""**select the car and view the Expense of that car**"""

import pandas as pd
import ipywidgets as widgets
from IPython.display import display

# Assuming df_automobile is the DataFrame containing the data

# Calculate expenses as 3/4 of the price
df_automobile['expenses'] = df_automobile['Price'] * 3 / 4  # Adjust the factor according to your expense calculation

# Group data by 'Make' (car model), 'Year', 'Condition', and 'insurance' columns and calculate the mean price and expenses
expensive_data = df_automobile.groupby(['Make', 'Year', 'Condition', 'insurance'])[['Price', 'expenses']].mean().reset_index()

# Create a function to generate a summary table for the selected car
def create_summary_table(car_model, data):
    selected_data = data[data['Make'] == car_model]
    total_price_sum = selected_data['Price'].sum()
    total_expenses_sum = selected_data['expenses'].sum()
    insurance = selected_data['insurance'].values[0]
    summary_df = pd.DataFrame({'Make': [car_model], 'Total Price Sum': [total_price_sum], 'Total Expenses Sum': [total_expenses_sum], 'Insurance': [insurance]})
    return summary_df

# Get unique car models for the dropdown list
car_models = expensive_data['Make'].unique()
dropdown = widgets.Dropdown(options=car_models, description='Car Model:')

# Display the dropdown
display(dropdown)

# Define a function to update the summary table based on the dropdown value
def on_change(change):
    if change['type'] == 'change' and change['name'] == 'value':
        selected_car = change['new']
        summary_table = create_summary_table(selected_car, expensive_data)
        print(summary_table)

# Call the on_change function when the dropdown value changes
dropdown.observe(on_change)

# Example usage for the initial value in the dropdown list
initial_car = dropdown.value
summary_table = create_summary_table(initial_car, expensive_data)
print(summary_table)

